#--
# Project:   active_rbac 
# File:      lib/active_rbac/acts_as_encrypts_password.rb
# Author:    Manuel Holtgrewe <purestorm at ggnore dot net>
# Copyright: (c) 2007 by Manuel Holtgrewe
# License:   MIT License as follows:
#
# Permission is hereby granted, free of charge, to any person obtaining 
# a copy of this software and associated documentation files (the 
# "Software"), to deal in the Software without restriction, including 
# without limitation the rights to use, copy, modify, merge, publish, 
# distribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the 
# following conditions:
#
# The above copyright notice and this permission notice shall be included 
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
#++

require File.dirname(__FILE__) + '/unit_test_helper'

require File.dirname(__FILE__) + '/../lib/active_rbac'

require 'test/unit'

require 'mocha'
require 'stubba'

# The test case for the acts_as_encrypts_password mixin.
#
# The test case uses Stubba so no real database connection is required for 
# testing the ActiveRecord mixin.
#
# "Modified" means modifications of the password in the methods' documentation
# below.
#
# The reason behind "< UnitTest.TestCase" is explained here:
# http://jayfields.blogspot.com/2006/06/ruby-on-rails-unit-tests.html
class ActsAsEncryptsPasswordTest < UnitTest.TestCase
  def setup
    # Create model class(es) we use for testing below.
    Object.const_set(:TestUser, Class.new(ActiveRecord::Base))
    TestUser.class_eval { acts_as_encrypts_password }

    @user_class = TestUser
    
    @fixture_password = 'password'
    
    @fixtures = {
      :test_user => [
        { :id => 1,
          :password => self.encrypt_password('sha1', @fixture_password, 'salt'),
          :password_salt => 'salt',
          :password_hash_type => 'sha1',
        }
      ]
    }
    @first_user_fixture = @fixtures[:test_user][0]
    
    @valid_data = { :password => 'valid-pw', :password_confirmation => 'valid-pw' }

    @invalid_patches = [ [ :password, 'not matching1' ], [ :password_confirmation, 'not matching2'] ]

    setup_stubs_for_test_user
  end
  
  def teardown
    # Remove the model class(es) we generated on the fly in setup.
    Object.send(:remove_const, :TestUser) if Object.const_defined?(:TestUser)
  end

  # Make sure the appropriate methods are generated by the mixin and that it
  # throws a NameError when password_hash_type= or password_salt= are called.
  def test_added_and_removed_methods
    user = @user_class.new
    
    # Perform assertions regarding the methods the object responds to at all.
    assert_respond_to(user, :password)
    assert_respond_to(user, :password=)
    assert_respond_to(user, :password_hash_type)
    assert_respond_to(user, :password_hash_type=) # but r/o, see below
    assert_respond_to(user, :password_salt) 
    assert_respond_to(user, :password_salt=) # but r/o, see below
    assert_respond_to(user, :password_new?)
    assert_respond_to(user, :password_equals?)
    
    # Perform assertions regarding the "removed" methods.
    assert_raises(NameError) { user.password_hash_type = 'sha1' }
    assert_raises(NameError) { user.password_salt = 'some salt' }
  end
  
  # Make sure that the attributes :password, :password_confirmation, :password_salt,
  # :password_hash_type are protected.
  def test_attr_protected
    [ :password, :password_confirmation, :password_salt, :password_hash_type ].each do |key|
      assert TestUser.attr_protected.include?(key)
    end
  end

  # Test that the ActiveRecord object behaves correctly when unsaved.
  def test_behaviour_when_new_and_unmodified
    user = @user_class.new
    
    assert_nil user.password
    assert_nil user.password_confirmation
    assert_nil user.password_salt
    assert_nil user.password_hash_type
    assert_equal true, user.password_new?
    assert_equal true, user.password_equals?('')
  end
  
  # Test that the ActiveRecord object behaves correctly when unsaved yet 
  # the password (and only the password) has been modified.
  def test_behaviour_when_new_and_password_is_modified
    user = @user_class.new
    user.password = @valid_data[:password]
    
    assert_equal @valid_data[:password], user.password
    assert_nil user.password_confirmation
    assert_nil user.password_salt
    assert_equal nil, user.password_hash_type
    assert_equal true, user.password_new?
    assert_equal true, user.password_equals?(@valid_data[:password])
  end
  
  # Test that the ActiveRecord object behaves correctly when unsaved yet 
  # the password confirmation (and only the password confirmation) has been 
  # modified.
  def test_behaviour_when_new_and_confirmation_is_modified
    user = @user_class.new
    user.password_confirmation = @valid_data[:password_confirmation]

    assert_nil user.password
    assert_equal @valid_data[:password_confirmation], user.password_confirmation
    assert_nil user.password_salt
    assert_equal nil, user.password_hash_type
    assert_equal true, user.password_new?
    assert_equal false, user.password_equals?(@valid_data[:password])
  end
  
  # Test that the ActiveRecord object behaves correctly when unsaved yet 
  # the password and the password confirmation (and nothing else) has been
  # modified.
  def test_behaviour_when_new_and_password_and_confirmation_are_modified
    user = @user_class.new
    user.password = @valid_data[:password]
    user.password_confirmation = @valid_data[:password_confirmation]

    assert_equal @valid_data[:password], user.password
    assert_equal @valid_data[:password_confirmation], user.password_confirmation
    assert_nil user.password_salt
    assert_equal nil, user.password_hash_type
    assert_equal true, user.password_new?
    assert_equal true, user.password_equals?(@valid_data[:password])
  end
  
  # Test that the ActiveRecord object behaves correctly after saving when it
  # was modified before.
  def test_behaviour_after_creating_record
    user = @user_class.new
    user.password = @valid_data[:password]
    user.password_confirmation = @valid_data[:password_confirmation]
    user.save!
    
    # saving the password will trigger the generation of a password salt and
    # encryption of the password; password confirmation will be set to nil
    assert_kind_of String, user.password_salt
    assert_equal 10, user.password_salt.length
    assert_equal(
      self.encrypt_password(user.password_hash_type, @valid_data[:password], user.password_salt),
      user.password)
    assert_equal(
      self.encrypt_password(user.password_hash_type, @valid_data[:password_confirmation], user.password_salt),
      user.password)

    assert_equal 'sha1', user.password_hash_type
    
    # the password should be marked as encrypted
    assert_equal false, user.password_new?
    
    # password_equals? should work nevertheless
    assert_equal true, user.password_equals?(@valid_data[:password])
  end
  
  # Test that the ActiveRecord object cannot be saved (created) when it 
  # contains invalid data.
  def test_does_not_validate_with_invalid_data
    @invalid_patches.each do |patch|
      key, value = patch
      
      user = @user_class.new
      
      invalid_data = @valid_data.dup
      invalid_data[key] = value
      invalid_data.each { |key,value| user.send("#{key}=", value) }
      
      # assert that the changes have been applied
      assert_equal invalid_data[:password], user.password
      assert_equal invalid_data[:password_confirmation], user.password_confirmation
      assert_nil user.password_salt
      assert_equal nil, user.password_hash_type
      assert_equal true, user.password_new?
      assert_equal true, user.password_equals?(invalid_data[:password])
      
      # assert validation error
      assert !user.save
      assert user.errors.on(:password)
      assert_equal 1, user.errors.size
      assert_kind_of String, user.errors.on(:password)
    end
  end
  
  # Test that the ActiveRecord object behaves correctly when loaded from
  # the database and has not been modified yet.
  def test_behaviour_when_loaded_and_unmodified
    user = @user_class.find :first # find any
    assert_not_nil user
    
    assert_equal @first_user_fixture[:password], user.password
    assert_nil user.password_confirmation
    assert_equal @first_user_fixture[:password_salt], user.password_salt
    assert_equal 'sha1', user.password_hash_type
    assert_equal false, user.password_new?
    assert_equal true, user.password_equals?(@fixture_password)
  end
  
  # Test that the ActiveRecord object behaves correctly when it has been
  # loaded from the database and the password has been changed.
  def test_behaviour_when_loaded_and_modified
    user = @user_class.find :first # find any
    user.password_confirmation = @valid_data[:password_confirmation]

    assert_equal @first_user_fixture[:password], user.password
    assert_equal @valid_data[:password_confirmation], user.password_confirmation
    assert_not_equal user.password, user.password_confirmation
    assert_equal @first_user_fixture[:password_salt], user.password_salt
    assert_equal 'sha1', user.password_hash_type
    assert_equal true, user.password_new?
    assert_equal false, user.password_equals?(@fixture_password)
  end
  
  # Test that the ActiveRecord object behaves correctly when it is stored
  # in the database but changes are to be saved.
  def test_behaviour_when_stored_with_changes
    user = @user_class.find :first # find any

    assert_equal false, user.password_new?
    
    @valid_data.each  { |key, value| user.send("#{key}=", value) }

    assert_equal true, user.password_new?

    old_salt = user.password_salt

    assert_equal true, user.password_new?

    user.save!

    # saving the password will trigger the generation of a password salt and
    # encryption of the password
    assert_kind_of String, user.password_salt
    assert_not_equal old_salt, user.password_salt
    assert_equal 10, user.password_salt.length
    assert_equal(
      self.encrypt_password(user.password_hash_type, @valid_data[:password], user.password_salt),
      user.password)
    assert_equal nil, user.password_confirmation

    assert_not_equal @first_user_fixture[:password_salt], user.password_salt
    assert_equal 'sha1', user.password_hash_type
    assert_equal false, user.password_new?
    assert_equal true, user.password_equals?(@valid_data[:password])
  end

  # Test that the ActiveRecord object behaves correctly when it is stored
  # in the database but no changes are to be saved.
  def test_behaviour_when_stored_without_changes
    user = @user_class.find :first # find any
    user.save

    assert_equal @first_user_fixture[:password], user.password
    assert_equal @first_user_fixture[:password_confirmation], user.password_confirmation
    assert_not_equal user.password, user.password_confirmation
    assert_equal @first_user_fixture[:password_salt], user.password_salt
    assert_equal 'sha1', user.password_hash_type
    assert_equal false, user.password_new?
    assert_equal true, user.password_equals?(@fixture_password)
  end

  # Test that the ActiveRecord object behaves correctly when it is stored
  # in the database but changes are to be saved with invalid data.
  def test_behaviour_when_stored_with_invalid_data
    @invalid_patches.each do |patch|
      user = @user_class.find :first # find any
      key, value = patch
      
      invalid_data = @valid_data.dup
      invalid_data[key] = value
      invalid_data.each { |key,value| user.send("#{key}=", value) }
      
      # assert that the changes have been applied
      assert_equal invalid_data[:password], user.password
      assert_equal invalid_data[:password_confirmation], user.password_confirmation
      assert_equal @first_user_fixture[:password_salt], user.password_salt
      assert_equal 'sha1', user.password_hash_type
      assert_equal true, user.password_new?
      assert_equal true, user.password_equals?(invalid_data[:password])

      # assert validation error
      assert !user.save
      assert user.errors.on(:password)
      assert_equal 1, user.errors.size
      assert_kind_of String, user.errors.on(:password)
    end
  end
  
  protected
  
    # Encrypts the password as ActsAsEncryptsPassword would.
    def encrypt_password(hash_type, password, salt)
      assert_equal 'sha1', hash_type
      
      require 'digest/sha1'
      Digest::SHA1.hexdigest(password + salt)
    end

    # Stub out methods in the EncryptPasswordUser class that require connections
    # to the database.
    def setup_stubs_for_test_user
      the_columns = [
        ar_column('password', 'string'),
        ar_column('password_salt', 'string'),
        ar_column('password_hash_type', 'string'),
      ]
      @user_class.stubs(:columns).returns(the_columns)
      
      # trans-what? we want to stub them out =)
      @user_class.stubs(:transaction).yields()
      
      # stub out everything after validation
      @user_class.any_instance.stubs(:create_without_callbacks)
      @user_class.any_instance.stubs(:update_without_callbacks)
      
      # Always return the @user_class fixture on find(:first).
      @user_class.stubs(:find).with(:first).returns(user_from_fixture(@first_user_fixture))
    end

    # Shortcut for ActiveRecord::ConnectionAdapters::Column.new(name, default, type, nullable)
    def ar_column(name, type, default=nil, nullable=false)
      ActiveRecord::ConnectionAdapters::Column.new(name, default, type, nullable)
    end
    
    # Takes a fixture hash and returns a new @user_class.
    def user_from_fixture(fixture)
      result = @user_class.new
      result.instance_eval do
        fixture.each { |key, value| write_attribute(key, value) }
        @new_record = false
      end
      
      result
    end
end